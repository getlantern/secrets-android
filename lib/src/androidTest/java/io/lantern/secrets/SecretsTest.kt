/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.lantern.secrets

import android.content.Context
import android.util.Base64
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import org.junit.runner.RunWith
import java.util.Arrays
import java.util.UUID
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotEquals
import kotlin.test.assertNotNull
import kotlin.test.assertNull
import kotlin.test.assertTrue
import kotlin.test.fail

private val charset = Charsets.UTF_8

@RunWith(AndroidJUnit4::class)
class SecretsTest {
    @Test
    fun testSecrets() {
        val ctx = InstrumentationRegistry.getInstrumentation().targetContext
        val prefs = ctx.getSharedPreferences(UUID.randomUUID().toString(), Context.MODE_PRIVATE)
        val secrets = Secrets(
            UUID.randomUUID().toString(),
            prefs,
        )

        val oldSecret = "I'm an old secret that wasn't secret".toByteArray(charset)
        prefs.edit().putString("oldSecret_unencrypted", Secrets.toBase64(oldSecret)).commit()
        val newSecret = "I'm a new secret".toByteArray(charset)
        secrets.put("newSecret", newSecret)
        assertTrue(
            Arrays.equals(newSecret, secrets.get("newSecret")),
            "new secret should round-trip successfully"
        )
        assertTrue(
            Arrays.equals(oldSecret, secrets.get("oldSecret")),
            "old unencrypted secret should still be available"
        )
        if (secrets.isEncrypted) {
            assertNull(
                prefs.getString("oldSecret_unencrypted", null),
                "old unencrypted secret should have been removed from database after first fetch"
            )
            assertNotNull(
                prefs.getString("oldSecret", null),
                "oldSecret should have been moved into encrypted value after first fetch"
            )
        }
        assertNotEquals(
            newSecret,
            prefs.getString("newSecret", null),
            "new secret should not be available unencrypted in preferences"
        )

        val generatedSecret = secrets.get("generated", 16)
        assertTrue(Arrays.equals(generatedSecret, secrets.get("generated")))
        assertEquals(16, generatedSecret.size)
    }

    @Test
    fun testBase64Migration() {
        val valueString = "some string"
        val value = valueString.toByteArray(charset)
        val defaultEncoded = Base64.encodeToString(value, Base64.DEFAULT)
        val decodedNewStyle = Base64.decode(defaultEncoded, Base64.NO_WRAP or Base64.NO_PADDING)
        assertEquals(valueString, decodedNewStyle.toString(charset))
    }

    @Test
    fun testEncodingMigration() {
        val ctx = InstrumentationRegistry.getInstrumentation().targetContext
        val prefs = ctx.getSharedPreferences(UUID.randomUUID().toString(), Context.MODE_PRIVATE)
        val legacyPrefs = ctx.getSharedPreferences(UUID.randomUUID().toString(), Context.MODE_PRIVATE)
        val secrets = Secrets(
            UUID.randomUUID().toString(),
            prefs,
            legacyPrefs
        )

        val legacySecret = Secrets.toBase64(Secrets.generate(16))
        legacyPrefs.edit().putString("secret", secrets.legacySeal(legacySecret)).commit()

        try {
            secrets.get("secret")
            fail("accessing insecure secret should have failed")
        } catch (e: InsecureSecretException) {
            assertEquals(
                legacySecret, e.secret,
                "exception should have contained legacy secret"
            )
            e.regenerate(16)
            val newSecret = secrets.get("secret")
            assertEquals(16, newSecret?.size)
        }
    }
}
